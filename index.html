<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Blue Protocol Module Calculator</title>
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<style>
body {
  font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
  background:#d4d0c8;
  color:#000;
  margin:0; padding:10px;
}
h1 { text-align:center; margin-bottom:20px; }
table {
  border-collapse: collapse;
  width:100%;
  margin-bottom:20px;
  background:#fff;
  box-shadow: inset 0 0 0 #888, 1px 1px 0 #888;
}
th, td {
  border:1px solid #888;
  padding:5px 8px;
  text-align:center;
  font-size:14px;
}
th { background:#0a64ad; color:#fff; font-weight:bold; }
input[type=number], input[name="name"]{ width:60px; text-align:center; border:1px inset #888; padding:2px; font-family: "Segoe UI", sans-serif; }
input[name="name"]{ width:120px; }
.btn { padding:4px 10px; margin:4px; cursor:pointer; border:2px outset #ccc; border-radius:2px; font-weight:bold; font-family: "Segoe UI", sans-serif; }
.btn-blue { background:#0a64ad; color:white; }
.btn-red { background:#c00; color:white; }
.btn-green { background:#0a7a0a; color:white; }
.best-combo td { background:#ffd700; font-weight:bold; }

.stats-toggle {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
  gap: 8px;
  max-height: 150px;
  overflow-y: auto;
  padding: 6px;
  border: 1px solid #aaa;
  background: #fff;
  border-radius: 8px;
}
.stats-toggle label {
  background: #f6f6f6;
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 4px 6px;
  cursor: pointer;
}
.stats-toggle label:hover {
  background: #e6f1ff;
}

.level-0 { background:#e0e0e0; }
.level-1 { background:#f4cccc; }
.level-2 { background:#fce5cd; }
.level-3 { background:#fff2cc; }
.level-4 { background:#d9ead3; }
.level-5 { background:#c9daf8; }
.level-6 { background:#9fc5e8; }
.container { max-width:1200px; margin:auto; }
</style>
</head>
<body>
<div class="container">
<h1>Blue Protocol Module Calculator</h1>

<input type="file" id="csvInput" accept=".csv">
<button class="btn btn-green" id="export-import">Export Imported Table CSV</button>
<button class="btn btn-blue" id="export-all">Export All Output Tables CSV</button>
<div id="root"></div>
</div>

<script type="text/javascript">
const e = React.createElement;

const STATS = [
  "Strength Boost", "Agility Boost", "Intellect Boost", "Special Attack", "Elite Strike",
  "Healing Boost", "Healing Enhance", "Resistance", "Armor", "Cast Focus",
  "Attack SPD", "Crit Focus", "Luck Focus", "DMG Stack", "Agile",
  "Life Condense", "First Aid", "Final Protection", "Life Wave", "Life Steal", "Team Luck & Crit"
];

const STAT_ICONS = {
  "Strength Boost": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_011.webp",
  "Agility Boost": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_039.webp",
  "Intellect Boost": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_034.webp",
  "Special Attack": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_002.webp",
  "Elite Strike": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_038.webp",
  "Healing Boost": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_023.webp",
  "Healing Enhance": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_042.webp",
  "Resistance": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_009.webp",
  "Armor": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_014.webp",
  "Cast Focus": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_013.webp",
  "Attack SPD": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_026.webp",
  "Crit Focus": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_019.webp",
  "Luck Focus": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_048.webp",
  "DMG Stack": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_016.webp",
  "Agile": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_006.webp",
  "Life Condense": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_012.webp",
  "First Aid": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_024.webp",
  "Final Protection": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_045.webp",
  "Life Wave": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_004.webp",
  "Life Steal": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_035.webp",
  "Team Luck & Crit": "https://assets-ng.maxroll.gg/sr-tools/assets/db/icons/items/modules/effects/mod_effect_icon_017.webp"
};

const thresholds = [[6,20],[5,16],[4,12],[3,8],[2,4],[1,1]];

function level_for(total){
  for(const [lvl,req] of thresholds){
    if(total >= req) return lvl;
  }
  return 0;
}

function combinations(arr, k){
  const results = [];
  function comb(current, start){
    if(current.length === k){ results.push([...current]); return; }
    for(let i=start;i<arr.length;i++){ current.push(arr[i]); comb(current,i+1); current.pop(); }
  }
  comb([],0);
  return results;
}

function getLevelClass(lvl){ return 'level-'+lvl; }

function exportCSVMultiple(tables){
  let csv = [];
  tables.forEach(tbl=>{
    csv.push(tbl.title);
    csv.push(tbl.headers.join(','));
    tbl.rows.forEach(r=>{ csv.push(r.join(',')); });
    csv.push('');
  });
  const blob = new Blob([csv.join('\n')], {type:'text/csv'});
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = "bpsr_module_output.csv";
  link.click();
}

function App(props){
  const initialData = props?.initialData || [{name:"X1", ...Object.fromEntries(STATS.map(s=>[s,0]))}];
  const [data,setData] = React.useState(initialData);
  const [bestResults,setBestResults] = React.useState({});
  const [visibleStats,setVisibleStats] = React.useState(STATS.reduce((acc,s)=>{acc[s]=false;return acc;},{}));
  const [calcMethod,setCalcMethod] = React.useState('highest'); // 'total' or 'highest'

  // Data handlers
  const handleChange = (i,key,val)=>{
    const copy = [...data]; copy[i][key] = key==="name"? val : Number(val)||0; setData(copy);
  }
  const handleAddRow = ()=>{
    const newModule = {name:`X${data.length+1}`};
    STATS.forEach(s=>newModule[s]=0);
    setData([...data,newModule]);
  }
  const handleRemoveRow = (i)=>setData(data.filter((_,idx)=>idx!==i));
  const toggleStat = (stat)=> setVisibleStats({...visibleStats, [stat]:!visibleStats[stat]});

  React.useEffect(() => {
    // Expose a function globally to update CSV
    window.loadCSVData = (formatted) => {
      setData(formatted);
    };
  }, []);

  // Compute best combos
  React.useEffect(()=>{
    if(data.length<4) return;
    const allComb = combinations(data,4);
    const results = [];
    allComb.forEach(combo=>{
      const sums = {}; const lvls = {};
      STATS.forEach(s=>{ sums[s]=combo.reduce((acc,m)=>acc+m[s],0); lvls[s]=level_for(sums[s]); });
      const min_lvl = Math.min(...Object.values(lvls));
      results.push({combo:combo.map(m=>m.name).join(","), sums, lvls, min_lvl});
    });

    // Top per stat
    const topPerStat = {};
    STATS.forEach(s=>{
      const sorted = [...results].sort((a,b)=>b.lvls[s]-a.lvls[s]);
      topPerStat[s] = sorted.slice(0,5);
    });

// Top Total / Highest Levels / Smart Combo
    let topTotal = [...results];
  // üìä Sort by sum of all levels
    if(calcMethod==='total'){
      topTotal.sort((a, b) => {
        const totalA = STATS.reduce((acc, s) => acc + (a.lvls[s] || 0), 0);
        const totalB = STATS.reduce((acc, s) => acc + (b.lvls[s] || 0), 0);
        return totalB - totalA; // highest total levels first
      });
  // üèÜ Sort by how many high-level stats each combo has
    } else if(calcMethod==='highest'){
      function levelVector(r){
        const counts = Array(7).fill(0);
        STATS.forEach(s=>counts[r.lvls[s]]++);
        return counts.reverse();
      }
      topTotal.sort((a,b)=>{
        const vecA = levelVector(a);
        const vecB = levelVector(b);
        for(let i=0;i<vecA.length;i++){ if(vecB[i]!==vecA[i]) return vecB[i]-vecA[i]; }
        return 0;
      });
  // üß† Smart mode: combine both level distribution and raw totals
    } else if(calcMethod === 'smart') {
      function levelVector(r){
        const counts = Array(7).fill(0);
        STATS.forEach(s=>counts[r.lvls[s]]++);
        return counts.reverse();
      }
      topTotal.sort((a,b)=>{
        const vecA = levelVector(a);
        const vecB = levelVector(b);
    
        // 1Ô∏è‚É£ Prioritize more high-level stats (6s > 5s > 4s‚Ä¶)
        for(let i=0;i<vecA.length;i++){
          if(vecB[i]!==vecA[i]) return vecB[i]-vecA[i];
        }
    
        // 2Ô∏è‚É£ If tied, compare sum of all levels
        const sumA = STATS.reduce((acc,s)=>acc+a.lvls[s],0);
        const sumB = STATS.reduce((acc,s)=>acc+b.lvls[s],0);
        if(sumB !== sumA) return sumB - sumA;
    
        // 3Ô∏è‚É£ Final tie-break: compare raw total stat values
        const rawA = STATS.reduce((acc,s)=>acc+a.sums[s],0);
        const rawB = STATS.reduce((acc,s)=>acc+b.sums[s],0);
        return rawB - rawA;
      });
    } else if (calcMethod === 'weighted') {
      // Higher levels are exponentially more valuable
      const weights = [0, 1, 2, 4, 8, 16, 32]; // index = level
      topTotal.sort((a,b)=>{
        const scoreA = STATS.reduce((acc,s)=>acc+weights[a.lvls[s]||0],0);
        const scoreB = STATS.reduce((acc,s)=>acc+weights[b.lvls[s]||0],0);
        return scoreB - scoreA;
      });
    } else if (calcMethod === 'balanced') {
      // Minimize variance between stat levels
      topTotal.sort((a,b)=>{
        const avgA = STATS.reduce((acc,s)=>acc+(a.lvls[s]||0),0)/STATS.length;
        const avgB = STATS.reduce((acc,s)=>acc+(b.lvls[s]||0),0)/STATS.length;
    
        const varA = STATS.reduce((acc,s)=>acc+Math.pow((a.lvls[s]||0)-avgA,2),0);
        const varB = STATS.reduce((acc,s)=>acc+Math.pow((b.lvls[s]||0)-avgB,2),0);
    
        // Prefer higher average, lower variance
        if(avgB!==avgA) return avgB - avgA;
        return varA - varB;
      });
    } else if (calcMethod === 'spike') {
      // Focus on the single best stat of the combo
      topTotal.sort((a,b)=>{
        const maxA = Math.max(...STATS.map(s=>a.lvls[s]||0));
        const maxB = Math.max(...STATS.map(s=>b.lvls[s]||0));
        if(maxB !== maxA) return maxB - maxA;
    
        // If tied, prefer higher total
        const totalA = STATS.reduce((acc,s)=>acc+(a.lvls[s]||0),0);
        const totalB = STATS.reduce((acc,s)=>acc+(b.lvls[s]||0),0);
        return totalB - totalA;
      });
    } else if (calcMethod === 'efficiency') {
      // Best ratio of total raw stat sum / number of high-level stats
      topTotal.sort((a,b)=>{
        const rawA = STATS.reduce((acc,s)=>acc+(a.sums[s]||0),0);
        const rawB = STATS.reduce((acc,s)=>acc+(b.sums[s]||0),0);
    
        const highCountA = STATS.filter(s=>a.lvls[s]>=4).length;
        const highCountB = STATS.filter(s=>b.lvls[s]>=4).length;
    
        const effA = rawA / (highCountA || 1);
        const effB = rawB / (highCountB || 1);
    
        return effB - effA;
      });
    } else if (calcMethod === 'synergy') {
      const SYNERGY_PAIRS = [
        ['Attack SPD','Crit Focus'],
        ['Healing Boost','Healing Enhance'],
        ['Strength Boost','Special Attack']
      ];
      topTotal.sort((a,b)=>{
        const baseA = STATS.reduce((acc,s)=>acc+(a.lvls[s]||0),0);
        const baseB = STATS.reduce((acc,s)=>acc+(b.lvls[s]||0),0);
    
        const synA = SYNERGY_PAIRS.reduce((acc,[s1,s2])=>{
          return acc + Math.min(a.lvls[s1]||0, a.lvls[s2]||0);
        },0);
        const synB = SYNERGY_PAIRS.reduce((acc,[s1,s2])=>{
          return acc + Math.min(b.lvls[s1]||0, b.lvls[s2]||0);
        },0);
    
        return (baseB+synB*2) - (baseA+synA*2);
      });
    }
    topTotal = topTotal.slice(0,10);

    // Best balanced
    const balanced = [...results].sort((a,b)=>{
      if(b.min_lvl!==a.min_lvl) return b.min_lvl - a.min_lvl;
      for(let s of STATS){ if(b.lvls[s]!==a.lvls[s]) return b.lvls[s]-a.lvls[s]; }
      return 0;
    }).slice(0,10);

    setBestResults({topPerStat, topTotal, balanced});
    window.bestResultsGlobal = {topPerStat, topTotal, balanced};
    window.appData = data;
  },[data,calcMethod]);

  // Render
  return e('div',null,
    e('div',{className:"mb-2"},
      e('button',{className:"btn btn-blue", onClick:handleAddRow},'+ Add Module'),
      e('button',{className:"btn btn-red", onClick:()=>setData([])},'Clear Table')
    ),
    e('div',{className:"stats-toggle"},
      STATS.map(s => e('label', { key: s, style:{marginRight:"10px", whiteSpace: 'normal', textAlign:'center'} },
        e('input', { type:'checkbox', checked:visibleStats[s], onChange:()=>toggleStat(s) }),
        e('img', { src: STAT_ICONS[s], alt:s, title:s, width:16, height:16, style:{verticalAlign:'middle', marginLeft:'4px', marginRight:'2px'} }),
        s
      ))
    ),
    e('div',{className:"calc-method-toggle", style:{margin:"10px 0"}},
      e('label',null,
        e('input',{type:'radio', checked:calcMethod==='total', onChange:()=>setCalcMethod('total')}), " Total Level"
      ),
      e('label',{style:{marginLeft:"20px"}},
        e('input',{type:'radio', checked:calcMethod==='highest', onChange:()=>setCalcMethod('highest')}), " Highest Levels"
      ),
      e('label',{style:{marginLeft:"20px"}},
        e('input',{type:'radio', checked:calcMethod==='smart', onChange:()=>setCalcMethod('smart')}), " Smart Combination"
      ),
      e('label',{style:{marginLeft:"20px"}},
        e('input',{type:'radio', checked:calcMethod==='weighted', onChange:()=>setCalcMethod('weighted')}), " Weighted Power"
      ),
      e('label',{style:{marginLeft:"20px"}},
        e('input',{type:'radio', checked:calcMethod==='balanced', onChange:()=>setCalcMethod('balanced')}), " Balanced Mode"
      ),
      e('label',{style:{marginLeft:"20px"}},
        e('input',{type:'radio', checked:calcMethod==='spike', onChange:()=>setCalcMethod('spike')}), " Spike Mode"
      ),
      e('label',{style:{marginLeft:"20px"}},
        e('input',{type:'radio', checked:calcMethod==='efficiency', onChange:()=>setCalcMethod('efficiency')}), " Efficiency Mode"
      ),
      e('label',{style:{marginLeft:"20px"}},
        e('input',{type:'radio', checked:calcMethod==='synergy', onChange:()=>setCalcMethod('synergy')}), " Synergy Mode"
      )
    ),
    e('table',null,
      e('thead',null,e('tr',null,
        e('th',null,'Module Name'),
        STATS.map(s => visibleStats[s] ? e('th', { key: s, style:{whiteSpace: 'normal', textAlign:'center'} },
          e('img', { src: STAT_ICONS[s], alt: s, title: s, width:20, height:20, style:{verticalAlign:'middle', marginRight:'4px'} }),
          s
        ) : null),
        e('th',null,'Remove')
      )),
      e('tbody',null,data.map((row,i)=>e('tr',{key:i},
        e('td',{className:'level-6'},row.name),
        STATS.map(s => visibleStats[s] ? e('td', { key: s, className: getLevelClass(level_for(row[s])) },
          e('div', { style:{display:'flex', alignItems:'center', justifyContent:'center', gap:'4px'} },
            e('img', { src: STAT_ICONS[s], alt: s, title: s, width:16, height:16 }),
            e('input', { type:'number', value: row[s], onChange: (e)=>handleChange(i,s,e.target.value), style:{width:'40px', textAlign:'center'} })
          )
        ) : null),
        e('td',null,e('button',{className:"btn btn-red", onClick:()=>handleRemoveRow(i)},'‚úï'))
      )))
    ),
    bestResults.topTotal && e('div',{className:'results'},
      e('h3', null, 
        calcMethod === 'total'      ? 'Top Total Combos (Highest Sum of Levels)' :
        calcMethod === 'highest'    ? 'Top Combos (Most High-Level Stats)' :
        calcMethod === 'smart'      ? 'Smart Combination Results (Weighted Hybrid Ranking)' :
        calcMethod === 'weighted'   ? 'Weighted Power Mode (Exponential Level Value)' :
        calcMethod === 'balanced'   ? 'Balanced Mode (Even Stat Distribution)' :
        calcMethod === 'spike'      ? 'Spike Mode (Specialized Peak Stats)' :
        calcMethod === 'efficiency' ? 'Efficiency Mode (Best Value per High Stat)' :
        calcMethod === 'synergy'    ? 'Synergy Mode (Complementary Stat Combos)' :
        'Top Combos'
      ),
      e('table',null,
        e('thead',null,e('tr',null,
          e('th',null,'Modules'),
          STATS.map(s => visibleStats[s] ? e('th', { key: s, style:{whiteSpace: 'normal', textAlign:'center'} },
            e('div', { style:{display:'flex', alignItems:'center', justifyContent:'center', gap:'4px'} },
              e('img', { src: STAT_ICONS[s], alt: s, title: s, width:16, height:16 }),
              s+' Lvl'
            )
          ) : null)
        )),
        e('tbody',null,bestResults.topTotal.map((r,i)=>e('tr',{key:i,className:i===0?'best-combo':''},
          e('td',null,r.combo),
          STATS.map(s=>visibleStats[s]?e('td',{key:s,className:getLevelClass(r.lvls[s])},r.lvls[s]):null)
        )))
      )
    ),
    Object.keys(bestResults.topPerStat || {}).map(stat=>{
      return e('div',{key:stat},
        e('h3',null,'Top '+stat+' combos'),
        e('table',null,
          e('thead',null,e('tr',null,
            e('th',null,'Modules'),
          STATS.map(s => visibleStats[s] ? e('th', { key: s, style:{whiteSpace: 'normal', textAlign:'center'} },
            e('div', { style:{display:'flex', alignItems:'center', justifyContent:'center', gap:'4px'} },
              e('img', { src: STAT_ICONS[s], alt: s, title: s, width:16, height:16 }),
              s+' Lvl'
            )
          ) : null)
          )),
          e('tbody',null,bestResults.topPerStat[stat].map((r,i)=>e('tr',{key:i,className:i===0?'best-combo':''},
            e('td',null,r.combo),
            STATS.map(s=>visibleStats[s]?e('td',{key:s,className:getLevelClass(r.lvls[s])},r.lvls[s]):null)
          )))
        )
      )
    }),
    bestResults.balanced && e('div',{className:'results'},
      e('h3',null,'Best Balanced combos (maximize min level)'),
      e('table',null,
        e('thead',null,e('tr',null,
          e('th',null,'Modules'),
          STATS.map(s => visibleStats[s] ? e('th', { key: s, style:{whiteSpace: 'normal', textAlign:'center'} },
            e('div', { style:{display:'flex', alignItems:'center', justifyContent:'center', gap:'4px'} },
              e('img', { src: STAT_ICONS[s], alt: s, title: s, width:16, height:16 }),
              s+' Lvl'
            )
          ) : null)
        )),
        e('tbody',null,bestResults.balanced.map((r,i)=>e('tr',{key:i,className:i===0?'best-combo':''},
          e('td',null,r.combo),
          STATS.map(s=>visibleStats[s]?e('td',{key:s,className:getLevelClass(r.lvls[s])},r.lvls[s]):null)
        )))
      )
    )
  );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(e(App));

// CSV Import
document.getElementById('csvInput').addEventListener('change', function (e) {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function (evt) {
    let text = evt.target.result;

    if (text.charCodeAt(0) === 0xfeff) text = text.slice(1);
    const lines = text.replace(/\r\n/g, '\n').trim().split('\n');
    const headers = lines[0].split(',').map(h => h.trim());
    const dataRows = lines.slice(1).filter(line => line.trim().length > 0);

    const rows = dataRows.map(line => {
      const vals = line.split(',').map(v => v.trim());
      const obj = {};
      headers.forEach((h, i) => obj[h] = vals[i]);
      return obj;
    });

    const formatted = rows.map(row => {
      const nameKey = Object.keys(row).find(k => k.toLowerCase().includes('module name')) || 'name';
      const newRow = { name: row[nameKey] || 'Module' };
      STATS.forEach(s => {
        newRow[s] = Number((row[s] || "0").trim());
      });
      return newRow;
    });

    console.log("‚úÖ Parsed rows:", formatted);
    // Update the existing App state instead of re-rendering
    if (window.loadCSVData) window.loadCSVData(formatted);
  };

  reader.readAsText(file);
});

// Export imported table
document.getElementById('export-import').addEventListener('click',()=>{
  const data = window.appData || [];
  if(!data.length) return;
  let csv = [ ["Module Name", ...STATS].join(",") ];
  data.forEach(row=>{
    const line = [row.name, ...STATS.map(s=>row[s])];
    csv.push(line.join(","));
  });
  const blob = new Blob([csv.join("\n")], {type:'text/csv'});
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = "imported_modules.csv";
  link.click();
});

// Export all output tables
document.getElementById('export-all').addEventListener('click',()=>{
  const bestResults = window.bestResultsGlobal;
  if(!bestResults) return alert("No results to export!");
  const tables = [];

  if(bestResults.topTotal){
    tables.push({
      title:"Top Total Combos",
      headers:["Modules", ...STATS.map(s=>"Lvl "+s)],
      rows: bestResults.topTotal.map(r=>[r.combo, ...STATS.map(s=>r.lvls[s])])
    });
  }

  for(const s of STATS){
    if(bestResults.topPerStat && bestResults.topPerStat[s]){
      tables.push({
        title:"Top "+s+" Combos",
        headers:["Modules", ...STATS.map(st=>"Lvl "+st)],
        rows: bestResults.topPerStat[s].map(r=>[r.combo, ...STATS.map(st=>r.lvls[st])])
      });
    }
  }

  if(bestResults.balanced){
    tables.push({
      title:"Best Balanced Combos",
      headers:["Modules", ...STATS.map(s=>"Lvl "+s)],
      rows: bestResults.balanced.map(r=>[r.combo, ...STATS.map(s=>r.lvls[s])])
    });
  }

  exportCSVMultiple(tables);
});
</script>

<footer style="
  text-align:center; 
  padding:15px; 
  background: linear-gradient(90deg, #0a64ad, #00aaff); 
  color:white; 
  margin-top:20px; 
  border-radius:10px; 
  font-weight:bold;
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  line-height:1.6;
">
  &copy; 2025 <span style="color:#ffd700;">Blue Protocol Calculator</span> üåü<br>
  Made for you with ‚ù§Ô∏è and lots of ‚òï<br>
  Big thanks to <a href="https://maxroll.gg/blue-protocol/resources/modules-guide" target="_blank" style="color:#ffdd00; text-decoration:underline;">Maxroll</a> for the awesome guides and in-game icons! üé®
</footer>

</body>
</html>
